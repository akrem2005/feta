import * as React from 'react';
import { Media, Peer, Room, VideoResolutionTier } from '../Definitions';
import { SignalingClient } from '../signaling';
interface ProviderDispatchProps {
    connect?: () => void;
    disconnect?: () => void;
    removeAllMedia?: () => void;
    setDefaultValues?: () => void;
}
interface ProviderStateProps {
    connectionState?: string;
    isSupportedBrowser?: boolean;
    signalingClient?: SignalingClient;
}
export interface ProviderProps extends ProviderStateProps, ProviderDispatchProps {
    configUrl: string;
    userData?: string;
    videoResolutionTiers?: VideoResolutionTier[];
    displayName?: string;
    desiredMedia?: 'video' | 'audio' | 'none';
    sharingFilter?: (opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean;
    render?: (props: ProviderStateProps) => React.ReactNode;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
}
/**
 * @description
 *
 * @public
 *
 */
declare class Provider extends React.Component<ProviderProps, any> {
    componentDidMount(): void;
    componentDidUpdate(prevProps: ProviderProps): void;
    componentWillUnmount(): void;
    render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
}
/**
 * @description
 *
 * @public
 * @example
 * <NotSupported>
 *   <p>This browser does not support WebRTC media features.</p>
 * </NotSupported>
 */
export declare const NotSupported: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): JSX.Element | null;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): JSX.Element | null;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): JSX.Element | null;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
/**
 * @description
 *
 * @public
 * @example
 * <NotConnected>
 *   <p>The client is not connected. It might be connecting or disconnected.</p>
 * </NotConnected>
 */
export declare const NotConnected: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
/**
 * @description
 * The `<Connected />` component renders its children when the SimpleWebRTC client is connected and ready.
 * @public
 * @example
 * <Connecting>
 *   <p>The client is connecting and not yet ready.</p>
 * </Connecting>
 */
export declare const Connecting: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
/**
 * @description
 * The `<Connecting />` component renders its children when the SimpleWebRTC client is starting and attempting to connect to the service.
 * @public
 * @example
 * <Connected>
 *   <p>The client is now ready.</p>
 * </Connected>
 */
export declare const Connected: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
/**
 * @description
 * The `<Disconnected />` component renders its children when the SimpleWebRTC client has lost connection with the service.
 * @public
 * @example
 * <Disconnected>
 *   <p>The client lost access to the signaling service.</p>
 * </Disconnected>
 */
export declare const Disconnected: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
/**
 * @description
 * The `<Failed />` component renders its children when the SimpleWebRTC client failed to receive its service configuration and can not continue.
 * @public
 * @example
 * <Failed>
 *   <p>There was an error initializing the client. The service might not be available.</p>
 * </Failed>
 */
export declare const Failed: import("react-redux").ConnectedComponent<{
    new (props: Partial<ProviderProps> | Readonly<Partial<ProviderProps>>): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    new (props: Partial<ProviderProps>, context: any): {
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
}, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    displayName?: string | undefined;
    ref?: React.LegacyRef<{
        render(): string | number | boolean | React.ReactFragment | JSX.Element | null | undefined;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<Partial<ProviderProps>>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<Partial<ProviderProps>>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<Partial<ProviderProps>>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<Partial<ProviderProps>>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<Partial<ProviderProps>>, nextState: Readonly<{}>, nextContext: any): void;
    }> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl?: string | undefined;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
declare const _default: import("react-redux").ConnectedComponent<typeof Provider, {
    key?: React.Key | null | undefined;
    children?: React.ReactNode | ((props: ProviderStateProps) => React.ReactNode);
    displayName?: string | undefined;
    ref?: React.LegacyRef<Provider> | undefined;
    render?: ((props: ProviderStateProps) => React.ReactNode) | undefined;
    configUrl: string;
    userData?: string | undefined;
    videoResolutionTiers?: VideoResolutionTier[] | undefined;
    desiredMedia?: "none" | "audio" | "video" | undefined;
    sharingFilter?: ((opts: {
        room: Room;
        user: Peer;
        peer: Peer;
        media: Media;
    }) => boolean) | undefined;
    connectionState?: string | undefined;
    isSupportedBrowser?: boolean | undefined;
    signalingClient?: SignalingClient | undefined;
    connect?: (() => void) | undefined;
    disconnect?: (() => void) | undefined;
    removeAllMedia?: (() => void) | undefined;
    setDefaultValues?: (() => void) | undefined;
    context?: React.Context<import("react-redux").ReactReduxContextValue<any, import("redux").AnyAction>> | undefined;
    store?: import("redux").Store<any, import("redux").AnyAction> | undefined;
}>;
export default _default;
